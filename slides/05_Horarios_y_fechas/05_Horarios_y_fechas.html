<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Programación con R</title>
    <meta charset="utf-8" />
    <meta name="author" content="Environmental Data Scientist      " />
    <script src="libs/header-attrs/header-attrs.js"></script>
    <link href="libs/font-awesome/css/all.css" rel="stylesheet" />
    <link href="libs/font-awesome/css/v4-shims.css" rel="stylesheet" />
    <link rel="stylesheet" href="..\my-theme.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Programación con R
## <br/> Marvin J. Quispe Sedano
### Environmental Data Scientist <br/><br/> <img src='../img/gif-logods.png' alt='envids' width='100' height='100'> <br/>
### Lima, 2021

---





layout: true
  
&lt;div class="my-footer"&gt;
&lt;span&gt;
&lt;a href="https://github.com/marvinjonathcn/curso_arcgis_intermedio" target="_blank"&gt; ArcGIS - Nivel Intermedio
&lt;/a&gt;
&lt;/span&gt;
&lt;/div&gt; 

---



class: inverse, center, middle

## CLASE 4 
### HORARIOS Y FECHAS CON R

---

## Introducción

- Las datos que se obtienen en intervalos de tiempo definidos en la mayoría de los casos se almacenan en una base de datos que contiene el tiempo exacto en el que fue tomado el valor.
- El lenguaje de programación R, dispone de dos clases específicamente diseñadas para el manejo de fechas dentro de su entorno.

&lt;img src='img/time-series.png' width='75%' height='75%' class='centerimage'&gt;

---

## Clases de horarios y/o fechas

- En R, disponemos de dos clases para los horarios y/o las fechas.
- La clase **Date** solo pude almacenar fechas.
- La clase **POSIXt** puede almacenar la fecha, hora y huso horario.


&lt;img src='img/time-series2.png' width='85%' height='85%' class='centerimage'&gt;

---

## Clase "Date"

- La clase **Date** almacena las fechas como el número de días transcurridos desde el 1 de enero de 1970, para las fechas anteriores el número se encuentra en sentido negativo. La función **unclass** nos permite conocer el valor numérico de una fecha.
- La función **as.Date()**, te permite crear un objeto de tipo **Date**.
- La función **Sys.Date()** te permite obtener la fecha actual de nuestro ordenador en formato **Date**.

---

- Creamos un objeto de clase **Date**.


```r

# CREANDO UN OBJETO DE TIPO DATE 

new_year =as.Date("31/12/2020",format="%d/%m/%Y")
new_year
## [1] "2020-12-31"

new_year2 =as.Date("31-12-2020",format="%d-%m-%Y")
new_year2
## [1] "2020-12-31"

new_year3 =as.Date("31 Diciembre 2020",format="%d %B %Y")
new_year3
## [1] "2020-12-31"

# CAMBIAR FORMATO DE UNA FECHA

format(new_year,"%A, %d de %B de %Y")
## [1] "jueves, 31 de Diciembre de 2020"

unclass(new_year)
## [1] 18627
```

---

## Formato de horarios y fechas

Símbolo | Significado 
------------ | ------------ 
%d | Día (numérico, de 1 a 31)
%a | Día de la semana abreviado a tres letras
%A | Día de la semana (completo)
%m | Mes (numérico, de 1 a 12)
%b | Mes abreviado a tres letras
%B | Mes (completo)
%y | Año con dos dígitos
%Y | Año completo

---

## Secuencias de horarios y fechas

- La función **seq()**, también nos permite crear secuencias de horarios y fechas de manera rápida especificando los valores de inicio, final y/o el intervalo.


```r

# CREANDO UN OBJETO DE TIPO DATE 

date1 =as.Date("31/12/2020",format="%d/%m/%Y")
date2 =as.Date("30-11-2020",format="%d-%m-%Y")

# CREAR UNA SECUENCIA DE FECHAS

seq1 &lt;- seq(date2, to = date1, by = "1 day")
seq1 &lt;- seq(date2, to = date1, by = "week")

```
---

## Clase "POSIXct" y "POSIXlt"

-  El almacenamiento interno de un objeto de clase **POSIXct** es el número de segundos transcurridos desde el 1 de enero de 1970. Mientras que el objeto con clase **POSIXlt** almacena internamente una lista que contiene el año, mes, dia, hora, minutos y segundos en componentes separadas.
- Aunque el almacenamiento interno de las dos clases de objetos **POSIX** son diferentes, ambos ejecutan sus operaciones llevando la fecha a segundos.

---

- Creamos un objeto de clase **POSIXct**.


```r

# CREANDO UN OBJETO DE TIPO POSIXct

new_year =as.POSIXct("31/12/2020",format="%d/%m/%Y")
new_year
## [1] "2020-12-31 -05"

new_year2 =as.POSIXct("31-12-2020 09:00",format="%d-%m-%Y %H:%M")
new_year2
## [1] "2020-12-31 09:00:00 -05"

new_year3 = as.POSIXct("31-12-2020 09:00",format="%d-%m-%Y %H:%M", tz="UTC")
new_year3
## [1] "2020-12-31 09:00:00 UTC"

# 

unclass(new_year)
## [1] 1609390800
## attr(,"tzone")
## [1] ""
```

---

- Creamos un objeto de clase **POSIXlt**.


```r

# CREANDO UN OBJETO DE TIPO POSIXlt

new_year =as.POSIXlt("31/12/2020",format="%d/%m/%Y")
new_year
## [1] "2020-12-31 -05"

new_year2 =as.POSIXlt("31-12-2020 09:00",format="%d-%m-%Y %H:%M")
new_year2
## [1] "2020-12-31 09:00:00 -05"

new_year3 = as.POSIXlt("31-12-2020 09:00",format="%d-%m-%Y %H:%M", tz="UTC")
new_year3
## [1] "2020-12-31 09:00:00 UTC"

# 

# unclass(new_year)

new_year$mday
## [1] 31

new_year$year
## [1] 120
```

---


class: inverse, center, middle

# GRACIAS! &lt;br/&gt;  &lt;a href="mailto: marvinjqs@gmail.com"&gt; &lt;img alt="gmail" src="../img/gmail-logo.gif" width='20%' height='50%'&gt; &lt;/a&gt; 



    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightLines": true,
"highlightStyle": "solarized-dark",
"countIncrementalSlides": true
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
